#pragma once
#include "common.hpp"
#include "logger.hpp"
#include "dump_data.hpp"
#include "memory.hpp"
#include "schemas.hpp"
#include "schema_tools.hpp"

extern std::string g_OutputPath;
extern std::vector<ModuleInfo> g_Modules;
ModuleInfo* FindModule(const std::string& name);

inline void GenerateSDK() {
    const std::string sdkPath = g_OutputPath + "/sdk";
    std::filesystem::create_directories(sdkPath);

    std::ofstream mainHeader(sdkPath + "/cs2_sdk.hpp");
    if (mainHeader.is_open()) {
        mainHeader << "// Auto-generated by cs2_dumper\n";
        mainHeader << "#pragma once\n\n";
        mainHeader << "#include \"sdk_types.hpp\"\n";
        mainHeader << "#include \"sdk_offsets.hpp\"\n";
        mainHeader << "#include \"sdk_forward.hpp\"\n";
    }

    std::ofstream fwdHeader(sdkPath + "/sdk_forward.hpp");
    if (fwdHeader.is_open()) {
        fwdHeader << "// Auto-generated forward declarations\n";
        fwdHeader << "#pragma once\n\n";
        fwdHeader << "namespace cs2 {\n";
        for (const auto& [scope, classes] : g_SchemaClasses) {
            (void)scope;
            for (const auto& cls : classes) {
                fwdHeader << "class " << MakeCppIdentifier(cls.name) << ";\n";
            }
        }
        fwdHeader << "} // namespace cs2\n";
    }

    std::ofstream typesHeader(sdkPath + "/sdk_types.hpp");
    if (typesHeader.is_open()) {
        typesHeader << "// Auto-generated common Source 2 types\n";
        typesHeader << "#pragma once\n\n";
        typesHeader << "#include <cstdint>\n\n";
        typesHeader << "namespace cs2 {\n";
        typesHeader << "struct Vector { float x, y, z; };\n";
        typesHeader << "struct QAngle { float pitch, yaw, roll; };\n";
        typesHeader << "struct Color { std::uint8_t r, g, b, a; };\n";
        typesHeader << "template<typename T> struct CHandle { std::uint32_t value; };\n";
        typesHeader << "} // namespace cs2\n";
    }

    std::ofstream offsetsHeader(sdkPath + "/sdk_offsets.hpp");
    if (offsetsHeader.is_open()) {
        offsetsHeader << "// Auto-generated offsets\n";
        offsetsHeader << "#pragma once\n\n";
        offsetsHeader << "#include <cstddef>\n\n";
        offsetsHeader << "namespace cs2 {\nnamespace offsets {\n";
        for (const auto& off : g_FoundOffsets) {
            offsetsHeader << "constexpr std::ptrdiff_t " << MakeCppIdentifier(off.module + "_" + off.name)
                          << " = 0x" << std::hex << off.offset << std::dec << ";\n";
        }
        offsetsHeader << "} // namespace offsets\n} // namespace cs2\n";
    }

    const std::string modulesPath = sdkPath + "/modules";
    std::filesystem::create_directories(modulesPath);
    for (const auto& [scope, classes] : g_SchemaClasses) {
        std::string fileBase = scope;
        std::replace(fileBase.begin(), fileBase.end(), '.', '_');
        std::ofstream modHeader(modulesPath + "/" + fileBase + ".hpp");
        if (!modHeader.is_open()) continue;

        modHeader << "// Auto-generated module SDK: " << scope << "\n";
        modHeader << "#pragma once\n\n";
        modHeader << "#include \"../sdk_types.hpp\"\n\n";
        modHeader << "namespace cs2 {\n";
        for (const auto& cls : classes) {
            modHeader << "struct " << MakeCppIdentifier(cls.name) << " {\n";
            for (const auto& field : cls.fields) {
                modHeader << "    // 0x" << std::hex << field.offset << std::dec << "\n";
                modHeader << "    " << GetCppType(field.type) << " " << MakeCppIdentifier(field.name) << ";\n";
            }
            modHeader << "};\n";
        }
        modHeader << "} // namespace cs2\n";
    }

    g_Logger.Success("SDK", "Generated SDK headers");
}

struct ValidationResult {
    std::string name;
    std::string module;
    uintptr_t offset = 0;
    bool valid = false;
    std::string reason;
};

inline std::vector<ValidationResult> g_ValidationResults;

inline void ValidateOffsetsRuntime() {
    g_ValidationResults.clear();
    g_Logger.Info("Validation", "Running structural offset validation...");

    for (const auto& off : g_FoundOffsets) {
        ValidationResult vr;
        vr.name = off.name;
        vr.module = off.module;
        vr.offset = off.offset;

        auto mod = FindModule(off.module);
        if (!mod) {
            vr.valid = false;
            vr.reason = "module_not_found";
        } else if (off.offset >= mod->size) {
            vr.valid = false;
            vr.reason = "offset_out_of_module";
        } else {
            vr.valid = true;
            vr.reason = "ok";
        }
        g_ValidationResults.push_back(std::move(vr));
    }

    int validCount = 0;
    for (const auto& vr : g_ValidationResults) {
        if (vr.valid) {
            ++validCount;
        }
    }
    g_Logger.Success("Validation", "Validated " + std::to_string(validCount) + "/" +
        std::to_string(g_ValidationResults.size()) + " offsets");
}

inline void WriteValidationReport() {
    const std::string reportPath = g_OutputPath + "/meta/validation_report.json";
    std::filesystem::create_directories(g_OutputPath + "/meta");
    std::ofstream out(reportPath);
    if (!out.is_open()) return;

    int validCount = 0;
    for (const auto& vr : g_ValidationResults) {
        if (vr.valid) ++validCount;
    }

    out << "{\n";
    out << "  \"summary\": {\n";
    out << "    \"total\": " << g_ValidationResults.size() << ",\n";
    out << "    \"valid\": " << validCount << ",\n";
    out << "    \"invalid\": " << (g_ValidationResults.size() - validCount) << "\n";
    out << "  },\n";
    out << "  \"entries\": [\n";
    for (size_t i = 0; i < g_ValidationResults.size(); ++i) {
        const auto& vr = g_ValidationResults[i];
        out << "    {\"name\":\"" << JsonEscape(vr.name) << "\",";
        out << "\"module\":\"" << JsonEscape(vr.module) << "\",";
        out << "\"offset\":\"0x" << std::hex << vr.offset << std::dec << "\",";
        out << "\"valid\":" << (vr.valid ? "true" : "false") << ",";
        out << "\"reason\":\"" << JsonEscape(vr.reason) << "\"}";
        out << (i + 1 < g_ValidationResults.size() ? "," : "") << "\n";
    }
    out << "  ]\n";
    out << "}\n";
    g_Logger.Success("Validation", "meta/validation_report.json written");
}

inline std::string GetBuildNumber() {
    uintptr_t buildOffset = 0;
    for (const auto& off : g_FoundOffsets) {
        if (off.module == "engine2.dll" && off.name == "dwBuildNumber") {
            buildOffset = off.offset;
            break;
        }
    }

    auto now = std::chrono::system_clock::now();
    auto time = std::chrono::system_clock::to_time_t(now);
    std::tm tm{};
    localtime_s(&tm, &time);
    char fallbackBuf[32];
    strftime(fallbackBuf, sizeof(fallbackBuf), "%Y%m%d_%H%M%S", &tm);

    auto engine = FindModule("engine2.dll");
    if (!engine || !buildOffset || buildOffset >= engine->size) {
        return fallbackBuf;
    }

    int32_t build = 0;
    if (!ReadInt32(engine->base + buildOffset, build) || build <= 0) {
        return fallbackBuf;
    }
    return std::to_string(build);
}

inline void SaveVersionedDump() {
    const std::string version = GetBuildNumber();
    const std::string versionsPath = g_OutputPath + "/versions";
    std::filesystem::create_directories(versionsPath);

    const std::string versionPath = versionsPath + "/" + version;
    std::filesystem::create_directories(versionPath);

    std::ofstream out(versionPath + "/summary.json");
    if (out.is_open()) {
        out << "{\n";
        out << "  \"version\": \"" << JsonEscape(version) << "\",\n";
        out << "  \"timestamp\": \"" << JsonEscape(GetCurrentTimestamp()) << "\",\n";
        out << "  \"counts\": {\n";
        out << "    \"offsets\": " << g_FoundOffsets.size() << ",\n";
        out << "    \"buttons\": " << g_FoundButtons.size() << ",\n";
        out << "    \"interfaces_modules\": " << g_Interfaces.size() << ",\n";
        out << "    \"schema_scopes\": " << g_SchemaClasses.size() << "\n";
        out << "  }\n";
        out << "}\n";
    }
    g_Logger.Success("Versioning", "Versioned dump snapshot created: " + version);
}

inline void GenerateHTMLDocumentation() {
    const std::string docsPath = g_OutputPath + "/docs";
    std::filesystem::create_directories(docsPath);

    std::ofstream out(docsPath + "/index.html");
    if (!out.is_open()) return;

    int totalInterfaces = 0;
    for (const auto& [mod, ifaces] : g_Interfaces) {
        (void)mod;
        totalInterfaces += static_cast<int>(ifaces.size());
    }

    int totalSchemaClasses = 0;
    int totalSchemaFields = 0;
    for (const auto& [scope, classes] : g_SchemaClasses) {
        (void)scope;
        totalSchemaClasses += static_cast<int>(classes.size());
        for (const auto& cls : classes) {
            totalSchemaFields += static_cast<int>(cls.fields.size());
        }
    }

    out << "<!doctype html><html><head><meta charset=\"utf-8\">";
    out << "<title>CS2 Dump Documentation</title>";
    out << "<style>body{font-family:Segoe UI,Arial,sans-serif;margin:24px;background:#0f1115;color:#e7eaf0;}"
        "h1,h2{color:#7dd3fc;}table{border-collapse:collapse;width:100%;margin-top:12px;}"
        "th,td{border:1px solid #2a3240;padding:8px;text-align:left;}th{background:#18202c;}"
        ".kpi{display:inline-block;margin-right:20px;padding:10px 14px;background:#18202c;border-radius:8px;}"
        "a{color:#93c5fd;text-decoration:none;}a:hover{text-decoration:underline;}</style></head><body>";
    out << "<h1>CS2 Dumper Report</h1>";
    out << "<p>Generated: " << GetCurrentTimestamp() << "</p>";
    out << "<div class=\"kpi\">Offsets: " << g_FoundOffsets.size() << "</div>";
    out << "<div class=\"kpi\">Buttons: " << g_FoundButtons.size() << "</div>";
    out << "<div class=\"kpi\">Interfaces: " << totalInterfaces << "</div>";
    out << "<div class=\"kpi\">Schema Classes: " << totalSchemaClasses << "</div>";
    out << "<div class=\"kpi\">Schema Fields: " << totalSchemaFields << "</div>";

    out << "<h2>Modules</h2><table><tr><th>Name</th><th>Base</th><th>Size</th></tr>";
    for (const auto& mod : g_Modules) {
        out << "<tr><td>" << JsonEscape(mod.name) << "</td><td>0x" << std::hex << mod.base
            << std::dec << "</td><td>" << mod.size << "</td></tr>";
    }
    out << "</table>";

    out << "<h2>Outputs</h2><ul>";
    out << "<li><a href=\"../output/meta/info.json\">output/meta/info.json</a></li>";
    out << "<li><a href=\"../exports/exports.json\">exports/exports.json</a></li>";
    out << "<li><a href=\"../rtti/classes.json\">rtti/classes.json</a></li>";
    out << "<li><a href=\"../convars/convars.json\">convars/convars.json</a></li>";
    out << "<li><a href=\"../vtables/vtables.json\">vtables/vtables.json</a></li>";
    out << "</ul>";

    out << "</body></html>";
    g_Logger.Success("HTML", "docs/index.html generated");
}
